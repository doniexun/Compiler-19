!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFFER_NUM	lexical.c	18;"	d	file:
CHAR_BUFFER	lexical.c	/^char CHAR_BUFFER[20] = {0}; \/\/用于输入字符的缓冲区$/;"	v
CHAR_FLAG	lexical.c	/^int CHAR_FLAG = 0;			\/\/缓冲区索引$/;"	v
COMMA	lexical.h	/^	SEMICO,L_BRACKET,R_BRACKET,COMMA,$/;"	e	enum:Token_Type
CONST_ID	lexical.h	/^	CONST_ID,$/;"	e	enum:Token_Type
Close_Scanner	lexical.c	/^void Close_Scanner(void)$/;"	f
DFA_STATE	lexical.c	/^int DFA_STATE = 0;	\/\/初始化状态为起始状态0;$/;"	v
DIV	lexical.h	/^	PLUS,MINUS,MUL,DIV,POWER,$/;"	e	enum:Token_Type
DRAW	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
ERRTOKEN	lexical.h	/^	ERRTOKEN$/;"	e	enum:Token_Type
FALSE	lexical.h	18;"	d
FOR	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
FP	lexical.c	/^FILE *FP = NULL; \/\/全局文件指针变量, 指向打开的文件.$/;"	v
FROM	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
FUNC	lexical.h	/^	FUNC,$/;"	e	enum:Token_Type
FuncPtr	lexical.h	/^	double		(* FuncPtr)(double);	\/\/属性,	若词法单元为函数则是函数指针$/;"	m	struct:Token
Get_Token	lexical.c	/^Token Get_Token(void)$/;"	f
IS	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
Init_Scanner	lexical.c	/^int Init_Scanner(const char* file_name)$/;"	f
L_BRACKET	lexical.h	/^	SEMICO,L_BRACKET,R_BRACKET,COMMA,$/;"	e	enum:Token_Type
MINUS	lexical.h	/^	PLUS,MINUS,MUL,DIV,POWER,$/;"	e	enum:Token_Type
MUL	lexical.h	/^	PLUS,MINUS,MUL,DIV,POWER,$/;"	e	enum:Token_Type
NONTOKEN	lexical.h	/^	NONTOKEN,$/;"	e	enum:Token_Type
Next_Char	lexical.c	/^char Next_Char() \/\/从文件中读取一个字符$/;"	f
OBJECT	Makefile	/^OBJECT=$(T1)$/;"	m
OBJECT	lex/Makefile	/^OBJECT=$(T1)$/;"	m
ORIGIN	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
PLUS	lexical.h	/^	PLUS,MINUS,MUL,DIV,POWER,$/;"	e	enum:Token_Type
POINT_FLAG	lexical.c	/^int POINT_FLAG = 0;			\/\/小数点标记, 遇到小数点标记为1, 用于检测多小数点的错误$/;"	v
POWER	lexical.h	/^	PLUS,MINUS,MUL,DIV,POWER,$/;"	e	enum:Token_Type
ROT	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
R_BRACKET	lexical.h	/^	SEMICO,L_BRACKET,R_BRACKET,COMMA,$/;"	e	enum:Token_Type
Retract	lexical.c	/^int Retract() \/\/将文件指针FP回退一个位置,成功返回0，失败返回错误码-1.$/;"	f
SCALE	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
SEMICO	lexical.h	/^	SEMICO,L_BRACKET,R_BRACKET,COMMA,$/;"	e	enum:Token_Type
STEP	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
T	lexical.h	/^	T,$/;"	e	enum:Token_Type
T1	Makefile	/^T1=lexical$/;"	m
T1	lex/Makefile	/^T1=lex$/;"	m
TO	lexical.h	/^	ORIGIN,SCALE,ROT,IS,TO,STEP,DRAW,FOR,FROM,$/;"	e	enum:Token_Type
TRUE	lexical.h	17;"	d
Token	lexical.h	/^struct Token	\/\/词法单元的数据结构 <单元名，属性值>$/;"	s
Token	lexical.h	/^typedef struct Token Token;$/;"	t	typeref:struct:Token
Token_Table	lexical.c	/^Token Token_Table[] =			\/\/存放<静态>词法单元的数据结构$/;"	v
Token_Type	lexical.h	/^enum Token_Type	\/\/词法单元的模式$/;"	g
Token_Type	lexical.h	/^typedef enum Token_Type Token_Type;$/;"	t	typeref:enum:Token_Type
__LEXICAL_H__	lexical.h	13;"	d
lexeme	lexical.h	/^	char*		lexeme;					\/\/属性, 原始输入的字符串$/;"	m	struct:Token
main	main.c	/^int main(int argc, char *argv[])$/;"	f
type	lexical.h	/^	Token_Type	type;					\/\/词法单元的模式\/类别$/;"	m	struct:Token
value	lexical.h	/^	double		value;					\/\/属性, 若词法单元为常数则是常数值$/;"	m	struct:Token
